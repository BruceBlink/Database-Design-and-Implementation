---
typora-root-url: ./..\..\public
---

# 第 3 章 磁盘和文件管理 (Chapter 3 Disk and File Management)

数据库引擎将其数据保存在磁盘和闪存驱动器等持久存储设备上。本章将探讨这些设备的特性，并考虑可以提高其速度和可靠性的技术（如 RAID）。本章还将考察操作系统提供的与这些设备交互的两个接口——块级接口和文件级接口——并提出一种最适合数据库系统的两种接口组合。最后，本章将详细研究 SimpleDB 文件管理器，学习其 API 和实现。

## 3.1 持久数据存储 (Persistent Data Storage)

数据库的内容必须持久保存，以便即使数据库系统或计算机宕机，数据也不会丢失。本节将介绍两种特别有用的硬件技术：硬盘驱动器和闪存驱动器。尽管闪存驱动器的重要性将随着技术的成熟而增加，但其普及程度尚不及硬盘驱动器。让我们从硬盘驱动器开始。

### 3.1.1 硬盘驱动器 (Disk Drives)

硬盘驱动器包含一个或多个**旋转盘片 (rotating platters)**。盘片上有**同心磁道 (concentric tracks)**，每个磁道由一系列字节组成。通过带有**读/写磁头 (read/write head)** 的**可移动臂 (movable arm)** 从盘片读取（和写入）字节。磁臂定位在所需磁道上，磁头可以在字节旋转通过其下方时读取（或写入）字节。图 3.1 描绘了单盘硬盘驱动器的俯视图。当然，此图并非按比例绘制，因为典型的盘片有数千个磁道。

![fig3-1](/images/chapter3/fig3-1.png)

现代硬盘驱动器通常有多个盘片。为了节省空间，盘片通常背靠背连接，形成一个看起来像双面盘片的东西；但在概念上，每个面仍然是一个独立的盘片。每个盘片都有自己的读/写磁头。这些磁头不能独立移动；相反，它们都连接到一个**单个执行器 (single actuator)**，该执行器同时将它们移动到每个盘片上的相同磁道。此外，一次只能有一个读/写磁头处于活动状态，因为到计算机的数据路径只有一个。图 3.2 描绘了多盘硬盘驱动器的侧视图。

![fig3-2](/images/chapter3/fig3-2.png)

硬盘驱动器的整体性能可以通过四个值来衡量：**容量 (capacity)**、**旋转速度 (rotation speed)**、**传输速率 (transfer rate)** 和**寻道时间 (seek time)**。

驱动器的**容量**是可以存储的字节数。该值取决于盘片数量、每个盘片的磁道数量以及每个磁道的字节数。鉴于盘片倾向于采用或多或少的标准尺寸，制造商主要通过增加盘片密度来增加容量，即通过在每个盘片上挤入更多磁道和每个磁道更多字节。现在，超过 40GB 的盘片容量已很常见。

**旋转速度**是盘片旋转的速率，通常以每分钟转数表示。典型速度范围为 5400 rpm 到 15,000 rpm。

**传输速率**是字节通过磁盘磁头的速度，以便传输到/从内存。例如，一整个磁道的字节可以在盘片旋转一圈的时间内传输。因此，传输速率由旋转速度和每磁道字节数共同决定。100 MB/s 的速率很常见。

**寻道时间**是执行器将磁盘磁头从当前位置移动到请求磁道所需的时间。此值取决于需要遍历的磁道数量。它可以低至 0（如果目标磁道与起始磁道相同）高至 15-20 毫秒（如果目标磁道和起始磁道位于盘片的不同末端）。平均寻道时间通常可以合理地估计执行器速度。现代磁盘的平均寻道时间约为 5 毫秒。

考虑以下示例。假设一个四盘硬盘驱动器以 10,000 rpm 的速度旋转，平均寻道时间为 5 毫秒。每个盘片包含 10,000 个磁道，每个磁道包含 500,000 字节。以下是一些计算值：

驱动器的容量：

500,000 字节/磁道 x 10,000 磁道/盘片 x 4 盘片/驱动器 = 20,000,000,000 字节，或大约 20GB

传输速率：

500,000 字节/转 x 10,000 转/60 秒 = 83,333,333 字节/秒，或大约 83MB/秒

### 3.1.2 访问硬盘驱动器 (Accessing a Disk Drive)

**磁盘访问**是读取磁盘驱动器中的一些字节到内存或将内存中的一些字节写入磁盘的请求。这些字节必须位于某个盘片上磁道的连续部分。硬盘驱动器分三个阶段执行磁盘访问：

- 它将磁盘磁头移动到指定的磁道。此时间称为**寻道时间 (seek time)**。
- 它等待盘片旋转，直到第一个所需的字节位于磁盘磁头下方。此时间称为**旋转延迟 (rotational delay)**。
- 随着盘片继续旋转，它读取（或写入）出现在磁盘磁头下方的每个字节，直到最后一个所需的字节出现。此时间称为**传输时间 (transfer time)**。

执行磁盘访问所需的时间是寻道时间、旋转延迟和传输时间之和。这些时间都受到磁盘机械运动的限制。机械运动比电运动慢得多，这就是硬盘驱动器比 RAM 慢得多的原因。寻道时间和旋转延迟尤其令人恼火。这两个时间都只是每次磁盘操作都必须等待的开销。

计算磁盘访问的确切寻道时间和旋转延迟是不切实际的，因为它需要知道磁盘的先前状态。相反，您可以使用它们的平均值来估计这些时间。您已经了解了平均寻道时间。平均旋转延迟很容易计算。旋转延迟可以低至 0（如果第一个字节恰好在磁头下方）高至完整旋转时间（如果第一个字节刚刚通过磁头）。平均而言，您将不得不等待 1/2 旋转，直到盘片定位到您想要的位置。因此，平均旋转延迟是旋转时间的一半。

传输时间也可以很容易地从传输速率计算出来。特别是，如果传输速率为 r 字节/秒，并且您正在传输 b 字节，则传输时间为 b/r 秒。

例如，考虑一个以 10,000 rpm 旋转的硬盘驱动器，其平均寻道时间为 5 毫秒，传输速率为 83 MB/秒。以下是一些计算出的成本：

平均旋转延迟：

60 秒/分钟 x 1 分钟/10,000 转 x 1/2 转 = 0.003 秒 或 3 毫秒

1 字节的传输时间：

1 字节 x 1 秒/83,000,000 字节 = 0.000000012 秒 或 0.000012 毫秒

1000 字节的传输时间：

1,000 字节 x 1 秒/83,000,000 字节 = 0.000012 秒 或 0.012 毫秒

访问 1 字节的估计时间：

5 毫秒（寻道）+ 3 毫秒（旋转延迟）+ 0.000012 毫秒（传输）= 8.000012 毫秒

访问 1000 字节的估计时间：

5 毫秒（寻道）+ 3 毫秒（旋转延迟）+ 0.012 毫秒（传输）= 8.012 毫秒

请注意，访问 1000 字节的估计访问时间与访问 1 字节的估计访问时间基本相同。换句话说，从磁盘访问少量字节是没有意义的。事实上，即使您想这样做，也无法做到。现代磁盘的构造使得每个磁道被划分为固定长度的扇区；磁盘读取（或写入）必须一次操作整个扇区。扇区的大小可能由磁盘制造商决定，或者在格式化磁盘时选择。典型的扇区大小为 512 字节。

### 3.1.3 提高磁盘访问时间 (Improving Disk Access Time)

由于硬盘驱动器非常慢，因此开发了几种技术来帮助缩短访问时间。本节将介绍三种技术：**磁盘缓存 (disk caches)**、**柱面 (cylinders)** 和**磁盘条带化 (disk striping)**。

#### 磁盘缓存 (Disk Caches)

**磁盘缓存**是与硬盘驱动器捆绑在一起的内存，通常足够大以存储数千个扇区的内容。每当硬盘驱动器从磁盘读取一个扇区时，它会将该扇区的内容保存在其缓存中；如果缓存已满，新扇区将替换旧扇区。当请求一个扇区时，硬盘驱动器会检查缓存。如果扇区恰好在缓存中，则可以立即将其返回给计算机，而无需实际进行磁盘访问。

假设一个应用程序在相对较短的时间内多次请求同一个扇区。第一个请求会将扇区带入缓存，随后的请求将从缓存中检索它，从而节省磁盘访问。然而，此功能对数据库引擎来说不是特别有用，因为它已经在进行自己的缓存（如第 4 章所示）。如果多次请求一个扇区，引擎将在其自己的缓存中找到该扇区，甚至不需要访问磁盘。

磁盘缓存的真正价值在于其**预取扇区 (pre-fetch sectors)** 的能力。磁盘驱动器可以读取包含该扇区的整个磁道到缓存中，而不是只读取请求的扇区，希望该磁道的其他扇区稍后会被请求。关键是读取整个磁道所需的时间并不比读取单个扇区多得多。特别是，没有旋转延迟，因为磁盘可以从读/写磁头下方恰好所在的任何扇区开始读取磁道，并在整个旋转过程中继续读取。比较访问时间：

读取一个扇区的时间 = 寻道时间 + 1/2 旋转时间 + 扇区旋转时间

读取一个磁道的时间 = 寻道时间 + 旋转时间

也就是说，读取单个扇区与读取包含多个扇区的整个磁道之间的差异小于磁盘旋转时间的一半。如果数据库引擎恰好请求了磁道上的另一个扇区，那么将整个磁道读入缓存将节省时间。

#### 柱面 (Cylinders)

数据库系统可以通过将相关信息存储在附近的扇区中来缩短磁盘访问时间。例如，存储文件的理想方式是将其内容放置在盘片的同一磁道上。如果磁盘进行基于磁道的缓存，这种策略显然是最佳的，因为整个文件将在一次磁盘访问中读取。但即使没有缓存，这种策略也很好，因为它消除了寻道时间——每次读取另一个扇区时，磁盘磁头都将已经位于正确的磁道上。

假设一个文件占用多个磁道。一个好主意是将其内容存储在盘片附近的磁道中，以便磁道之间的寻道时间尽可能小。然而，一个更好的主意是将其内容存储在其他盘片的同一磁道上。由于每个盘片的读/写磁头都一起移动，因此所有具有相同磁道号的磁道都可以无需额外寻道时间进行访问。

具有相同磁道号的磁道集称为**柱面 (cylinder)**，因为如果您从磁盘顶部观察这些磁道，它们会描述圆柱体的外部。实际上，可以将柱面视为一个非常大的磁道，因为它的所有扇区都可以以零额外寻道时间进行访问。

#### 磁盘条带化 (Disk Striping)

另一种缩短磁盘访问时间的方法是使用**多个磁盘驱动器**。两个小驱动器比一个大驱动器快，因为它们包含两个独立的执行器，因此可以同时响应两个不同的扇区请求。例如，两个 20 GB 的磁盘持续工作，速度大约是单个 40 GB 磁盘的两倍。这种加速效果很好：通常，N 个磁盘的速度大约是单个磁盘的 N 倍。（当然，几个较小的驱动器也比单个大驱动器更昂贵，因此效率的提高是以成本为代价的。）

然而，如果多个小磁盘无法保持忙碌，它们的效率就会丧失。例如，假设一个磁盘包含常用文件，而其他磁盘包含很少使用的归档文件。那么第一个磁盘将承担所有工作，而其他磁盘大部分时间处于空闲状态。这种设置的效率将与单个磁盘大致相同。

因此，问题是如何在多个磁盘之间平衡工作负载。数据库管理员可以尝试分析文件使用情况，以便最好地分配每个磁盘上的文件，但这种方法不切实际：它难以操作，难以保证，并且必须随着时间的推移不断重新评估和修改。

幸运的是，有一种更好的方法，称为**磁盘条带化 (disk striping)**。

磁盘条带化策略使用**控制器**将较小的磁盘隐藏起来，使其在操作系统看来像一个单个的大磁盘。控制器将虚拟磁盘上的扇区请求映射到实际磁盘上的扇区请求。映射工作原理如下。假设有 N 个小磁盘，每个磁盘有 k 个扇区。虚拟磁盘将有 N * k 个扇区；这些扇区以交替模式分配给真实磁盘的扇区。磁盘 0 将包含虚拟扇区 0、N、2N 等。磁盘 1 将包含虚拟扇区 1、N+1、2N+1 等，以此类推。术语“磁盘条带化”源于以下图像：如果您想象每个小磁盘都涂有不同的颜色，那么虚拟磁盘看起来像有条纹，其扇区涂有交替的颜色。参见图 3.3。

![fig3-3](/images/chapter3/fig3-3.png)

磁盘条带化是有效的，因为它将数据库均匀地分布在小磁盘上。如果一个随机扇区请求到达，那么该请求将以相等的概率发送到其中一个小磁盘。如果几个连续扇区的请求到达，它们将被发送到不同的磁盘。因此，磁盘保证以尽可能均匀的方式工作。

### 3.1.4 通过镜像提高磁盘可靠性 (Improving Disk Reliability by Mirroring)

数据库用户希望他们的数据安全地保存在磁盘上，不会丢失或损坏。不幸的是，硬盘驱动器并非完全可靠。盘片上的磁性材料可能会退化，导致扇区无法读取。或者一块灰尘或剧烈移动可能导致读/写磁头刮擦盘片，损坏受影响的扇区（“磁头崩溃”）。

防止磁盘故障最明显的方法是**保留磁盘内容的副本**。例如，您可以每晚备份磁盘；当磁盘发生故障时，您只需购买一个新磁盘并将备份复制到其上。这种策略的问题是，您会丢失磁盘从备份时到发生故障时之间发生的所有更改。解决此问题的唯一方法是在更改发生时立即复制磁盘的每次更改。换句话说，您需要保留两个相同的磁盘版本；这些版本被称为彼此的**镜像 (mirrors)**。

与条带化一样，需要一个**控制器**来管理两个镜像磁盘。当数据库系统请求磁盘读取时，控制器可以访问任一磁盘的指定扇区。当请求磁盘写入时，控制器对两个磁盘执行相同的写入。理论上，这两个磁盘写入可以并行执行，这不需要额外的时间。然而，在实践中，为了防止系统崩溃，**顺序写入镜像很重要**。问题是，如果系统在磁盘写入过程中崩溃，该扇区的内容就会丢失。因此，如果两个镜像都并行写入，两个扇区副本都可能丢失，而如果镜像顺序写入，则至少有一个镜像不会损坏。

假设镜像对中的一个磁盘发生故障。数据库管理员可以通过执行以下程序恢复系统：

1. 关闭系统。
2. 用新磁盘替换发生故障的磁盘。
3. 将数据从完好的磁盘复制到新磁盘。
4. 重新启动系统。

不幸的是，这个过程并非万无一失。如果在复制到新磁盘的过程中完好的磁盘发生故障，数据仍然可能丢失。两个磁盘在几个小时内都发生故障的可能性很小（根据今天的磁盘，大约是 1/60,000），但如果数据库很重要，这种小风险可能无法接受。您可以通过使用**三个镜像磁盘而不是两个**来降低风险。在这种情况下，只有当所有三个磁盘在相同的几个小时内都发生故障时，数据才会丢失；这种可能性虽然不为零，但非常小，可以放心地忽略。

**镜像可以与磁盘条带化共存。** 一种常见的策略是镜像条带化磁盘。例如，可以在四个 20 GB 的驱动器上存储 40 GB 的数据：其中两个驱动器将进行条带化，另外两个将是条带化驱动器的镜像。这种配置既快速又可靠。参见图 3.4。

![fig3-4](/images/chapter3/fig3-4.png)

### 3.1.5 通过存储奇偶校验提高磁盘可靠性 (Improving Disk Reliability by Storing Parity)

镜像的缺点是需要两倍的磁盘来存储相同数量的数据。当使用磁盘条带化时，这种负担尤其明显——如果您想使用 15 个 20 GB 的驱动器存储 300 GB 的数据，那么您将需要再购买 15 个驱动器作为它们的镜像。对于大型数据库安装来说，通过条带化许多小磁盘来创建巨大的虚拟磁盘并不少见，而购买相同数量的磁盘仅仅为了镜像的前景是不吸引人的。如果能在不使用这么多镜像磁盘的情况下从故障磁盘中恢复，那将是件好事。

事实上，有一种巧妙的方法可以使用**单个磁盘来备份任意数量的其他磁盘**。该策略通过在备份磁盘上存储**奇偶校验（parity）**信息来实现。对于一组位 S，奇偶校验定义如下：

- 如果 S 包含奇数个 1，则 S 的奇偶校验为 1。
- 如果 S 包含偶数个 1，则 S 的奇偶校验为 0。

换句话说，如果您将奇偶校验位添加到 S 中，您将始终拥有偶数个 1。

奇偶校验具有以下有趣且重要的特性：**任何位的值都可以从其他位的值中确定，只要您也知道奇偶校验。** 例如，假设 S = {1, 0, 1}。S 的奇偶校验为 0，因为它有偶数个 1。假设您丢失了第一个位的值。由于奇偶校验为 0，集合 {?, 0, 1} 必须有偶数个 1；因此，您可以推断缺失的位必须是 1。对其他每个位（包括奇偶校验位）也可以进行类似的推断。

奇偶校验的这种用法扩展到磁盘。假设您有 N + 1 个大小相同的磁盘。您选择其中一个磁盘作为**奇偶校验盘（parity disk）**，让其他 N 个磁盘保存**条带化数据（striped data）**。奇偶校验盘的每个位都是通过计算所有其他磁盘相应位的奇偶校验来计算的。如果任何磁盘发生故障（包括奇偶校验盘），该磁盘的内容可以通过逐位查看其他磁盘的内容来重建。参见图 3.5。

![fig3-5](/images/chapter3/fig3-5.png)

磁盘由控制器管理。读写请求的处理方式与条带化基本相同——控制器确定哪个磁盘保存请求的扇区并执行该读写操作。不同之处在于，写请求还必须更新奇偶校验盘的相应扇区。控制器可以通过确定修改扇区的哪些位发生了变化来计算更新后的奇偶校验；规则是如果一个位发生变化，则相应的奇偶校验位也必须发生变化。因此，控制器需要**四次磁盘访问**来执行扇区写入操作：它必须读取扇区和相应的奇偶校验扇区（以便计算新的奇偶校验位），并且必须写入两个扇区的新内容。

这种奇偶校验信息的使用有些神奇，因为它能够可靠地备份任意数量的其他磁盘。然而，这种魔力伴随着两个缺点。

使用奇偶校验的第一个缺点是**扇区写入操作更耗时**，因为它需要从两个磁盘进行读取和写入。经验表明，使用奇偶校验会使条带化的效率降低约 20%。

奇偶校验的第二个缺点是，**数据库更容易受到无法恢复的多磁盘故障的影响**。考虑当一个磁盘发生故障时会发生什么——所有其他磁盘都需要重建发生故障的磁盘，其中任何一个磁盘的故障都是灾难性的。如果数据库由许多小磁盘组成（例如大约 100 个），那么发生第二次故障的可能性变得非常真实。将这种情况与镜像进行对比，在镜像中，从故障磁盘恢复只需要其镜像不发生故障，这发生的可能性要小得多。

### 3.1.6 RAID

前几节讨论了使用多个磁盘的三种方式：**条带化**以加快磁盘访问时间，**镜像**和**奇偶校验**以防止磁盘故障。这些策略使用控制器向操作系统隐藏多个磁盘的存在，并提供单个**虚拟磁盘**的错觉。控制器将每个虚拟读/写操作映射到一个或多个底层磁盘上的操作。控制器可以以软件或硬件实现，尽管硬件控制器更普遍。

这些策略是更大策略集合的一部分，称为 **RAID**，代表**廉价冗余磁盘阵列（Redundant Array of Inexpensive Disks）**。RAID 共有七个级别。

- **RAID-0** 是**条带化**，不提供任何防止磁盘故障的保护。如果其中一个条带化磁盘发生故障，则整个数据库可能会被毁坏。
- **RAID-1** 是**镜像条带化**。
- **RAID-2** 使用**位条带化**而不是扇区条带化，并使用基于纠错码的冗余机制而不是奇偶校验。这种策略已被证明难以实现且性能不佳。它已不再使用。
- **RAID-3** 和 **RAID-4** 使用**条带化和奇偶校验**。它们的区别在于 RAID-3 使用**字节条带化**，而 RAID-4 使用**扇区条带化**。一般来说，扇区条带化往往更高效，因为它对应于磁盘访问的单元。
- **RAID-5** 类似于 RAID-4，不同之处在于，它**没有将所有奇偶校验信息存储在一个单独的磁盘上，而是将奇偶校验信息分布在数据磁盘上。** 也就是说，如果有 N 个数据磁盘，则每个磁盘的每第 N 个扇区都包含奇偶校验信息。这种策略比 RAID-4 更高效，因为不再有单个奇偶校验盘成为瓶颈。参见练习 3.5。
- **RAID-6** 类似于 RAID-5，不同之处在于它保留了**两种奇偶校验信息**。因此，这种策略能够处理两个并发磁盘故障，但需要另一个磁盘来保存额外的奇偶校验信息。

最流行的两种 RAID 级别是 **RAID-1** 和 **RAID-5**。它们之间的选择实际上是**镜像与奇偶校验**的选择。在数据库安装中，镜像往往是更可靠的选择，首先是因为它的速度和鲁棒性，其次是因为额外磁盘驱动器的成本已经变得非常低。

### 3.1.7 闪存驱动器 (Flash Drives)

硬盘驱动器在当前的数据库系统中很常见，但它们有一个无法克服的缺点——它们的运行完全依赖于旋转盘片和移动执行器的机械活动。这个缺点使得硬盘驱动器与电子存储器相比本质上较慢，并且容易受到跌落、振动和其他冲击的损坏。

**闪存 (Flash memory)** 是一种较新的技术，有可能取代硬盘驱动器。它使用类似于 RAM 的半导体技术，但**不需要不间断的电源**。由于其活动完全是电动的，因此它比硬盘驱动器更快地访问数据，并且没有可损坏的移动部件。当前闪存驱动器的寻道时间约为 50 微秒，比硬盘驱动器快约 100 倍。当前闪存驱动器的传输速率取决于其连接的总线接口。通过快速内部总线连接的闪存驱动器与硬盘驱动器相当；然而，外部 USB 闪存驱动器比硬盘驱动器慢。

**闪存会磨损**。每个字节可以被重写固定次数；尝试写入已达到其限制的字节将导致闪存驱动器故障。目前，这个最大次数达到数百万次，对于大多数数据库应用程序来说已经相当高。高端驱动器采用“磨损均衡 (wear-leveling)”技术，自动将频繁写入的字节移动到写入较少的位置；这种技术允许驱动器运行，直到驱动器上的所有字节都达到其重写限制。

闪存驱动器向操作系统提供**基于扇区的接口**，这使得闪存驱动器看起来像硬盘驱动器。可以使用 RAID 技术与闪存驱动器，尽管条带化不太重要，因为闪存驱动器的寻道时间非常低。

闪存驱动器采用的主要障碍是其**价格**。目前价格大约是同等硬盘驱动器的 100 倍。尽管闪存和磁盘技术的价格将继续下降，但最终闪存驱动器将足够便宜，可以被视为主流。届时，硬盘驱动器可能会被降级为存档存储和超大型数据库的存储。

闪存还可以用作**持久前端**来增强硬盘驱动器。如果数据库完全适合闪存，那么硬盘驱动器将永远不会被使用。但随着数据库变大，使用频率较低的扇区将迁移到磁盘。

就数据库引擎而言，**闪存驱动器具有与硬盘驱动器相同的特性：它是持久的、慢速的，并且以扇区方式访问。** （它只是比硬盘驱动器慢得少。）因此，我将遵守当前的术语，并在本书的其余部分将持久存储器称为“磁盘”。
