---
typora-root-url: ./..\..\public
---

# 第 4 章 内存管理 (Chapter 4 Memory Management)

本章将研究数据库引擎的两个组件：**日志管理器 (log manager)** 和**缓冲区管理器 (buffer manager)**。每个组件都负责特定的文件：日志管理器负责日志文件，缓冲区管理器负责数据文件。

这两个组件都面临着如何高效管理磁盘块与主内存之间读写的问题。数据库内容通常远大于主内存，因此这些组件可能需要将块在内存中**移入移出 (shuttle blocks in and out of memory)**。本章将检查它们的内存需求以及它们使用的内存管理算法。日志管理器仅支持对日志文件的**顺序访问 (sequential access)**，并采用一个简单、最优的内存管理算法。另一方面，缓冲区管理器必须支持对用户文件的**任意访问 (arbitrary access)**，这是一个更困难的挑战。

## 4.1 数据库内存管理的两个原则 (Two Principles of Database Memory Management)

回想一下，数据库引擎读取磁盘值的唯一方法是将其所在的块读入内存中的一个页面，而写入磁盘值的唯一方法是将修改后的页面写回其块。数据库引擎在磁盘和内存之间移动数据时遵循两个重要原则：**最小化磁盘访问**，以及**不依赖虚拟内存**。

### 原则 1: 最小化磁盘访问 (Principle 1: Minimize Disk Accesses)

考虑一个应用程序，它从磁盘读取数据，搜索数据，执行各种计算，进行一些更改，然后将数据写回。您如何估计这需要多长时间？回想一下，RAM 操作比闪存快 1000 多倍，比磁盘快 100,000 倍。这意味着在大多数实际情况中，从磁盘读/写块所需的时间**至少**与在 RAM 中处理块所需的时间一样长。因此，数据库引擎可以做的最重要的事情就是**最小化块访问**。

最小化块访问的一种方法是**避免多次访问同一个磁盘块**。这种问题在计算的许多领域都会出现，并且有一个标准解决方案，称为**缓存 (caching)**。例如，CPU 有一个本地硬件缓存，用于存储以前执行的指令；如果下一条指令在缓存中，CPU 就无需从 RAM 加载它。另一个例子是，浏览器会保留以前访问过的网页的缓存；如果用户请求一个恰好在缓存中的页面（例如，通过点击浏览器的“后退”按钮），浏览器就可以避免从网络检索它。

数据库引擎使用**内存页**来缓存磁盘块。通过跟踪哪些页面包含哪些块的内容，引擎可能能够通过使用现有页面来满足客户端请求，从而避免磁盘读取。同样，引擎只在必要时将页面写入磁盘，希望通过一次磁盘写入完成对页面的多次更改。

最小化磁盘访问的需求非常重要，它渗透到数据库引擎的整个实现中。例如，引擎使用的检索算法之所以被选择，正是因为它们节俭地访问磁盘。当一个 SQL 查询有几种可能的检索策略时，查询规划器会选择它认为需要最少磁盘访问次数的策略。

### 原则 2: 不依赖虚拟内存 (Principle 2: Don’t Rely on Virtual Memory)

现代操作系统支持**虚拟内存 (virtual memory)**。操作系统给每个进程一个错觉，认为它拥有大量内存来存储其代码和数据。进程可以在其虚拟内存空间中任意分配对象；操作系统将每个虚拟页面映射到物理内存中的一个实际页面。操作系统支持的虚拟内存空间通常远大于计算机的物理内存。由于并非所有虚拟页面都能放入物理内存，因此操作系统必须将其中一些存储在磁盘上。当进程访问不在内存中的虚拟页面时，就会发生**页面交换 (page swap)**。操作系统选择一个物理页面，将该页面的内容写入磁盘（如果它已被修改），然后将虚拟页面的保存内容从磁盘读取到该页面。

数据库引擎管理磁盘块最直接的方法是为每个块分配自己的虚拟页面。例如，它可以为每个文件保留一个页面数组，每个文件的每个块都有一个槽位。这些数组会很大，但它们会适应虚拟内存。当数据库系统访问这些页面时，虚拟内存机制会根据需要将它们在磁盘和物理内存之间交换。这是一种简单、易于实现的策略。不幸的是，它有一个严重的问题，那就是**操作系统而非数据库引擎控制页面何时写入磁盘**。由此产生了两个问题。

第一个问题是，操作系统的页面交换策略会**损害数据库引擎在系统崩溃后恢复的能力**。原因（正如您将在第 5 章中看到的那样）是修改过的页面会有一些相关的日志记录，这些日志记录必须在页面之前写入磁盘。（否则，日志记录将无法用于帮助数据库在系统崩溃后恢复。）由于操作系统不知道日志，它可能会在不写入其日志记录的情况下交换出修改过的页面，从而破坏恢复机制。

第二个问题是，操作系统**不知道哪些页面当前正在使用，哪些页面数据库引擎不再关心**。操作系统可以做出有根据的猜测，例如选择交换最近最少访问的页面。但是，如果操作系统猜测不正确，它将交换出再次需要的页面，导致两次不必要的磁盘访问。另一方面，数据库引擎对需要哪些页面有更好的了解，可以做出更明智的猜测。

因此，数据库引擎必须**管理自己的页面**。它通过分配相对少量的、它知道能够放入物理内存的页面来做到这一点；这些页面被称为数据库的**缓冲区池 (buffer pool)**。引擎会跟踪哪些页面可用于交换。当一个块需要读入一个页面时，数据库引擎（而不是操作系统）从缓冲区池中选择一个可用页面，如果需要，将其内容（及其日志记录）写入磁盘，然后才读入指定的块。
