---
typora-root-url: ./..\..\public
---

# 第 4 章 内存管理 (Chapter 4 Memory Management)

本章将研究数据库引擎的两个组件：**日志管理器 (log manager)** 和**缓冲区管理器 (buffer manager)**。每个组件都负责特定的文件：日志管理器负责日志文件，缓冲区管理器负责数据文件。

这两个组件都面临着如何高效管理磁盘块与主内存之间读写的问题。数据库内容通常远大于主内存，因此这些组件可能需要将块在内存中**移入移出 (shuttle blocks in and out of memory)**。本章将检查它们的内存需求以及它们使用的内存管理算法。日志管理器仅支持对日志文件的**顺序访问 (sequential access)**，并采用一个简单、最优的内存管理算法。另一方面，缓冲区管理器必须支持对用户文件的**任意访问 (arbitrary access)**，这是一个更困难的挑战。

## 4.1 数据库内存管理的两个原则 (Two Principles of Database Memory Management)

回想一下，数据库引擎读取磁盘值的唯一方法是将其所在的块读入内存中的一个页面，而写入磁盘值的唯一方法是将修改后的页面写回其块。数据库引擎在磁盘和内存之间移动数据时遵循两个重要原则：**最小化磁盘访问**，以及**不依赖虚拟内存**。

### 原则 1: 最小化磁盘访问 (Principle 1: Minimize Disk Accesses)

考虑一个应用程序，它从磁盘读取数据，搜索数据，执行各种计算，进行一些更改，然后将数据写回。您如何估计这需要多长时间？回想一下，RAM 操作比闪存快 1000 多倍，比磁盘快 100,000 倍。这意味着在大多数实际情况中，从磁盘读/写块所需的时间**至少**与在 RAM 中处理块所需的时间一样长。因此，数据库引擎可以做的最重要的事情就是**最小化块访问**。

最小化块访问的一种方法是**避免多次访问同一个磁盘块**。这种问题在计算的许多领域都会出现，并且有一个标准解决方案，称为**缓存 (caching)**。例如，CPU 有一个本地硬件缓存，用于存储以前执行的指令；如果下一条指令在缓存中，CPU 就无需从 RAM 加载它。另一个例子是，浏览器会保留以前访问过的网页的缓存；如果用户请求一个恰好在缓存中的页面（例如，通过点击浏览器的“后退”按钮），浏览器就可以避免从网络检索它。

数据库引擎使用**内存页**来缓存磁盘块。通过跟踪哪些页面包含哪些块的内容，引擎可能能够通过使用现有页面来满足客户端请求，从而避免磁盘读取。同样，引擎只在必要时将页面写入磁盘，希望通过一次磁盘写入完成对页面的多次更改。

最小化磁盘访问的需求非常重要，它渗透到数据库引擎的整个实现中。例如，引擎使用的检索算法之所以被选择，正是因为它们节俭地访问磁盘。当一个 SQL 查询有几种可能的检索策略时，查询规划器会选择它认为需要最少磁盘访问次数的策略。

### 原则 2: 不依赖虚拟内存 (Principle 2: Don’t Rely on Virtual Memory)

现代操作系统支持**虚拟内存 (virtual memory)**。操作系统给每个进程一个错觉，认为它拥有大量内存来存储其代码和数据。进程可以在其虚拟内存空间中任意分配对象；操作系统将每个虚拟页面映射到物理内存中的一个实际页面。操作系统支持的虚拟内存空间通常远大于计算机的物理内存。由于并非所有虚拟页面都能放入物理内存，因此操作系统必须将其中一些存储在磁盘上。当进程访问不在内存中的虚拟页面时，就会发生**页面交换 (page swap)**。操作系统选择一个物理页面，将该页面的内容写入磁盘（如果它已被修改），然后将虚拟页面的保存内容从磁盘读取到该页面。

数据库引擎管理磁盘块最直接的方法是为每个块分配自己的虚拟页面。例如，它可以为每个文件保留一个页面数组，每个文件的每个块都有一个槽位。这些数组会很大，但它们会适应虚拟内存。当数据库系统访问这些页面时，虚拟内存机制会根据需要将它们在磁盘和物理内存之间交换。这是一种简单、易于实现的策略。不幸的是，它有一个严重的问题，那就是**操作系统而非数据库引擎控制页面何时写入磁盘**。由此产生了两个问题。

第一个问题是，操作系统的页面交换策略会**损害数据库引擎在系统崩溃后恢复的能力**。原因（正如您将在第 5 章中看到的那样）是修改过的页面会有一些相关的日志记录，这些日志记录必须在页面之前写入磁盘。（否则，日志记录将无法用于帮助数据库在系统崩溃后恢复。）由于操作系统不知道日志，它可能会在不写入其日志记录的情况下交换出修改过的页面，从而破坏恢复机制。

第二个问题是，操作系统**不知道哪些页面当前正在使用，哪些页面数据库引擎不再关心**。操作系统可以做出有根据的猜测，例如选择交换最近最少访问的页面。但是，如果操作系统猜测不正确，它将交换出再次需要的页面，导致两次不必要的磁盘访问。另一方面，数据库引擎对需要哪些页面有更好的了解，可以做出更明智的猜测。

因此，数据库引擎必须**管理自己的页面**。它通过分配相对少量的、它知道能够放入物理内存的页面来做到这一点；这些页面被称为数据库的**缓冲区池 (buffer pool)**。引擎会跟踪哪些页面可用于交换。当一个块需要读入一个页面时，数据库引擎（而不是操作系统）从缓冲区池中选择一个可用页面，如果需要，将其内容（及其日志记录）写入磁盘，然后才读入指定的块。

------

## 4.2 日志信息管理 (Managing Log Information)

每当用户更改数据库时，数据库引擎都必须**跟踪该更改**，以备需要撤销。描述更改的值保存在**日志记录 (log record)** 中，日志记录存储在**日志文件 (log file)** 中。新的日志记录会**追加到日志的末尾**。

**日志管理器 (log manager)** 是数据库引擎中负责将日志记录写入日志文件的组件。日志管理器不理解日志记录的内容——这项职责属于第 5 章的恢复管理器。相反，日志管理器将日志视为一个不断增长的日志记录序列。

本节将研究日志管理器在将日志记录写入日志文件时如何管理内存。考虑图 4.1 所示的算法，这是将记录追加到日志的最直接方法。

```txt
1. 分配一个内存页面。
2. 将日志文件的最后一个块读入该页面。
3a. 如果有空间，将日志记录放在页面上其他记录之后，并将页面写回磁盘。
3b. 如果没有空间，则分配一个新的空页面，将日志记录放入该页面，
    并将该页面追加到日志文件末尾的新块中。
```

**图 4.1 将新记录追加到日志的简单（但低效）算法**


此算法要求每个追加的日志记录进行一次磁盘读取和一次磁盘写入。它简单但效率非常低。图 4.2 说明了日志管理器在算法的第 3a 步进行到一半时的操作。日志文件包含三个块，这些块包含八条记录，标记为 r1 到 r8。日志记录的大小可能不同，这就是为什么块 0 中可以容纳四条记录，而块 1 中只能容纳三条记录的原因。块 2 尚未满，只包含一条记录。内存页面包含块 2 的内容。除了记录 r8，一条新的日志记录（记录 r9）刚刚被放入页面中。

现在假设日志管理器通过将页面写回文件的块 2 来完成算法。当日志管理器最终被要求向文件添加另一条日志记录时，它将执行算法的第 1 步和第 2 步，并将块 2 读入一个页面。但请注意，此磁盘读取是完全不必要的，因为现有的日志页面已经包含块 2 的内容！因此，算法的第 1 步和第 2 步是不必要的。**日志管理器只需要永久分配一个页面来包含最后一个日志块的内容。** 结果是，所有的磁盘读取都被消除了。

![fig4-2](/images/chapter4/fig4-2.png)

减少磁盘写入也是可能的。在上述算法中，日志管理器每次向页面添加新记录时，都会将其页面写入磁盘。查看图 4.2，您可以看到无需立即将记录 r9 写入磁盘。只要页面有空间，每个新日志记录都可以简单地添加到页面中。当页面变满时，日志管理器可以将页面写入磁盘，清除其内容，然后重新开始。这种新算法将导致每个日志块恰好一次磁盘写入，这显然是最佳的。

此算法有一个小问题：由于日志管理器无法控制的情况，日志页面可能需要在其变满之前写入磁盘。问题在于，**缓冲区管理器不能将修改过的数据页面写入磁盘，除非该页面关联的日志记录也已写入磁盘。** 如果这些日志记录中的任何一个恰好在日志页面中但尚未在磁盘上，则日志管理器必须将其页面写入磁盘，无论页面是否已满。这个问题将在第 5 章中解决。

图 4.3 给出了最终的日志管理算法。此算法在两个地方将内存页面写入磁盘：当需要强制将日志记录写入磁盘时，以及当页面已满时。因此，一个内存页面可能会被写入同一个日志块多次。但由于这些磁盘写入是绝对必要的且无法避免的，您可以得出结论，该算法是最佳的。

```txt
1. 永久分配一个内存页面来保存日志文件的最后一个块的内容。称此页面为 P。
2. 当提交新的日志记录时：
   a) 如果 P 中没有空间，则：
      将 P 写入磁盘并清除其内容。
   b) 将新日志记录追加到 P 中。
3. 当数据库系统请求将特定日志记录写入磁盘时：
   a) 确定该日志记录是否在 P 中。
   b) 如果是，则将 P 写入磁盘。
```

**图 4.3 最佳日志管理算法**
