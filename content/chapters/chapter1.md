---
typora-root-url: ./..\..\public
---

# 数据库系统(Database System)

数据库系统在计算机行业中扮演着重要的角色。一些数据库系统（例如 Oracle）是极其复杂的，通常运行在大型高端机器上。另一些（例如 SQLite）则小巧、精简，旨在存储特定于应用程序的数据。尽管它们用途广泛，但所有数据库系统都具有相似的功能。本章将探讨数据库系统必须解决的问题及其应具备的能力。它还将介绍本书中将讨论的 Derby 和 SimpleDB 数据库系统。

## 1.1 为什么要使用数据库系统？ (Why a Database System?)

数据库是存储在计算机上的数据集合。数据库中的数据通常组织成记录，例如员工记录、医疗记录、销售记录等。图 1.1 描绘了一个数据库，其中包含大学学生及其所修课程的信息。该数据库将作为本书贯穿始终的示例。图 1.1 的数据库包含五种类型的记录：

- **STUDENT 记录**：记录每位曾就读于该大学的学生。每条记录包含学生的 **ID 号**、**姓名**、**毕业年份**和学生主修系的 **ID**。
- **DEPT 记录**：记录大学中的每个系。每条记录包含系的 **ID 号**和**名称**。
- **COURSE 记录**：记录大学提供的每门课程。每条记录包含课程的 **ID 号**、**标题**以及开设该课程的系的 **ID**。
- **SECTION 记录**：记录每门课程中曾开设的每个班级。每条记录包含班级的 **ID 号**、开设班级的**年份**、课程的 **ID** 以及教授该班级的**教授**。
- **ENROLL 记录**：记录学生选修的每门课程。每条记录包含选课 **ID 号**、学生和所修课程班级的 **ID 号**，以及学生在该课程中获得的**成绩**。

图 1.1 只是这些记录的概念性图片。它没有说明记录如何存储或如何访问。有许多可用的软件产品，称为**数据库系统**，它们提供了一整套用于管理记录的功能。

![fig1-1](/images/chapter1/fig1-1.png)

“管理”记录意味着什么？数据库系统必须具备哪些功能，哪些功能是可选的？以下五个要求似乎是根本性的：

- **数据库必须是持久的。** 否则，一旦计算机关闭，记录就会消失。
- **数据库可以共享。** 许多数据库，例如我们的大学数据库，旨在由多个并发用户共享。
- **数据库必须保持准确。** 如果用户无法信任数据库的内容，它就会变得毫无用处和价值。
- **数据库可能非常庞大。** 图 1.1 的数据库只包含 29 条记录，这小得可笑。数据库包含数百万（甚至数十亿）条记录并不少见。
- **数据库必须可用。** 如果用户无法轻松获取他们想要的数据，他们的生产力就会受到影响，他们就会吵着要不同的产品。

以下小节将探讨这些要求的影响。每个要求都迫使数据库系统包含越来越多的功能，导致其复杂性超出您的预期。

------

### 1.1.1 记录存储 (Record Storage)

使数据库持久化的一种常见方法是将其记录存储在文件中。最简单直接的方法是数据库系统将记录存储在文本文件中，每种记录类型一个文件；每条记录可以是一行文本，其值用制表符分隔。图 1.2 描绘了 STUDENT 记录文本文件的开头。

这种方法的好处是用户可以用文本编辑器检查和修改文件。不幸的是，这种方法效率太低，无法派上用场，原因有二。

第一个原因是**大型文本文件更新时间过长**。例如，假设有人从 STUDENT 文件中删除了 Joe 的记录。数据库系统别无选择，只能重写从 Amy 记录开始的文件，将每个后续记录向左移动。尽管重写一个小文件所需的时间可以忽略不计，但重写一个 1 GB 的文件很容易花费几分钟，这是不可接受的长时间。数据库系统需要更巧妙地存储记录，以便文件更新只需要小型、局部的重写。

第二个原因是**大型文本文件读取时间过长**。考虑在 STUDENT 文件中搜索 2019 届的学生。唯一的方法是顺序扫描文件。顺序扫描效率可能非常低。您可能知道几种内存中的数据结构，例如树和哈希表，它们可以实现快速搜索。数据库系统需要使用类似的数据结构来实现其文件。例如，数据库系统可能会使用一种结构来组织文件中的记录，以方便某种特定类型的搜索（例如，按学生姓名、毕业年份或专业），或者它可能会创建多个辅助文件，每个文件都方便不同类型的搜索。这些辅助文件称为**索引**，是第 12 章的主题。

### 1.1.2 多用户访问 (Multi-user Access)

当许多用户共享一个数据库时，他们很可能会**并发访问**其某些数据文件。并发性是件好事，因为每个用户都可以快速得到服务，而无需等待其他用户完成。但是过多的并发性是不好的，因为它可能导致数据库变得不准确。例如，考虑一个旅行规划数据库。假设两个用户试图预订一个还有 40 个座位的航班。如果两个用户并发读取相同的航班记录，他们都会看到 40 个可用座位。然后他们都修改记录，使航班现在有 39 个可用座位。糟糕！两个座位已被预订，但数据库中只记录了一个预订。

解决这个问题的方法是**限制并发性**。数据库系统应该允许第一个用户读取航班记录并看到 40 个可用座位，然后阻塞第二个用户，直到第一个用户完成。当第二个用户恢复时，它将看到 39 个可用座位并将其修改为 38，这是正确的。通常，数据库系统必须能够检测到用户何时即将执行与另一个用户的操作冲突的动作，然后（并且仅在此时）阻止该用户执行，直到第一个用户完成。

用户可能还需要**撤消**他们所做的数据库更新。例如，假设用户在旅行规划数据库中搜索马德里的行程，并找到了一个有可用航班和有空房酒店的日期。现在假设用户预订了航班，但在预订过程中，该日期的所有酒店都住满了。在这种情况下，用户可能需要撤消航班预订并尝试不同的日期。

**不可撤消的更新不应该对数据库的其他用户可见**。否则，另一个用户可能会看到更新，认为数据是“真实”的，并根据它做出决定。因此，数据库系统必须为用户提供指定其更改何时永久化的能力；用户被认为**提交**了更改。一旦用户提交，更改就会变得可见且无法撤消。第 5 章将探讨这些问题。

### 1.1.3 处理灾难 (Dealing with Catastrophe)

假设您正在运行一个程序，为所有教授加薪，此时数据库系统意外崩溃。系统重启后，您发现有些教授的工资更新了，但有些没有。您该怎么办？您不能仅仅重新运行程序，因为那样会导致一些教授获得双倍加薪。相反，您需要数据库系统能够从崩溃中**优雅地恢复**，撤消崩溃发生时所有正在运行的程序的更新。这样做的机制很有趣且不简单，将在第 5 章中探讨。

### 1.1.4 内存管理 (Memory Management)

数据库需要存储在**持久内存**中，例如磁盘驱动器或闪存驱动器。闪存驱动器比磁盘驱动器快约 100 倍，但也贵得多。典型的访问时间，磁盘约为 6 毫秒，闪存约为 60 微秒。然而，这两个时间都比主内存（或 RAM）慢几个数量级，RAM 的访问时间约为 60 纳秒。也就是说，RAM 比闪存快约 1000 倍，比磁盘快 100,000 倍。

为了了解这种性能差异的影响以及数据库系统面临的随之而来的问题，请考虑以下类比。假设您想吃一块巧克力曲奇饼。有三种获取方式：从您厨房、从附近杂货店或通过邮购。在这个类比中，您的厨房对应 RAM，附近商店对应闪存驱动器，邮购公司对应磁盘。假设从您的厨房拿到曲奇饼需要 5 秒。从类比商店拿到曲奇饼将需要 5000 秒，超过一小时。这意味着要去商店，排很长的队，买曲奇饼，然后返回。从类比邮购公司拿到曲奇饼将需要 500,000 秒，超过 5 天。这意味着在线订购曲奇饼并使用标准交付方式运输。从这个角度来看，闪存和磁盘内存看起来非常慢。

等等！情况更糟。数据库对并发性和可靠性的支持会使事情变得更慢。如果其他人正在使用您想要的数据，那么您可能被迫等待直到数据被释放。在我们的类比中，这对应于到达杂货店，发现曲奇饼卖完了，迫使您等到它们补货。

换句话说，数据库系统面临以下难题：它必须**管理比主内存系统更多的数据**，**使用更慢的设备**，**多个人争夺数据的访问权**，并且**使其完全可恢复**，同时还要**保持合理的响应时间**。

解决这个难题的很大一部分是使用**缓存**。每当数据库系统需要处理一条记录时，它都会将其加载到 RAM 中并尽可能长时间地保留在那里。因此，主内存将包含当前正在使用的数据库部分。所有读写都发生在 RAM 中。这种策略的优点是使用快速的主内存而不是慢速的持久内存，但缺点是数据库的持久版本可能会过时。数据库系统需要实现技术来使数据库的持久版本与 RAM 版本保持同步，即使在系统崩溃（RAM 内容被销毁时）的情况下也是如此。第 4 章将探讨各种缓存策略。

### 1.1.5 可用性 (Usability)

如果用户无法轻松提取他们想要的数据，数据库就没什么用。例如，假设用户想知道所有 2019 年毕业学生的姓名。在没有数据库系统的情况下，用户将被迫编写一个程序来扫描学生文件。图 1.3 给出了这样一个程序的 Java 代码，假设文件以文本形式存储。请注意，大多数 Java 代码都在处理文件解码、读取每条记录并将其拆分为要检查的值数组。用于确定所需学生姓名（**粗体显示**）的代码隐藏在无趣的文件操作代码中。

```java
public static List<String> getStudents2019() {
    List<String> result = new ArrayList<>();
    FileReader rdr = new FileReader("students.txt");
    BufferedReader br = new BufferedReader(rdr);
    String line = br.readLine();
    while (line != null) {
        String[] vals = line.split("\t");
        String gradyear = vals[2];
        if (gradyear.equals("2019"))
            result.add(vals[1]);
        line = br.readLine();
    }
    return result;
}
```

因此，大多数数据库系统都支持**查询语言**，以便用户可以轻松指定他们想要的数据。关系数据库的标准查询语言是 **SQL**。图 1.3 的代码可以用一个 SQL 语句来表达：

```sql
select SName from STUDENT where GradYear = 2019
```

这个 SQL 语句比 Java 程序短得多、清晰得多，主要是因为它指定了要从文件中提取的值，而无需指定如何检索它们。
