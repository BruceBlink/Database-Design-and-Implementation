---
typora-root-url: ./..\..\public
---

# 数据库系统(Database System)

数据库系统在计算机行业中扮演着重要的角色。一些数据库系统（例如 Oracle）是极其复杂的，通常运行在大型高端机器上。另一些（例如 SQLite）则小巧、精简，旨在存储特定于应用程序的数据。尽管它们用途广泛，但所有数据库系统都具有相似的功能。本章将探讨数据库系统必须解决的问题及其应具备的能力。它还将介绍本书中将讨论的 Derby 和 SimpleDB 数据库系统。

## 1.1 为什么要使用数据库系统？ (Why a Database System?)

数据库是存储在计算机上的数据集合。数据库中的数据通常组织成记录，例如员工记录、医疗记录、销售记录等。图 1.1 描绘了一个数据库，其中包含大学学生及其所修课程的信息。该数据库将作为本书贯穿始终的示例。图 1.1 的数据库包含五种类型的记录：

- **STUDENT 记录**：记录每位曾就读于该大学的学生。每条记录包含学生的 **ID 号**、**姓名**、**毕业年份**和学生主修系的 **ID**。
- **DEPT 记录**：记录大学中的每个系。每条记录包含系的 **ID 号**和**名称**。
- **COURSE 记录**：记录大学提供的每门课程。每条记录包含课程的 **ID 号**、**标题**以及开设该课程的系的 **ID**。
- **SECTION 记录**：记录每门课程中曾开设的每个班级。每条记录包含班级的 **ID 号**、开设班级的**年份**、课程的 **ID** 以及教授该班级的**教授**。
- **ENROLL 记录**：记录学生选修的每门课程。每条记录包含选课 **ID 号**、学生和所修课程班级的 **ID 号**，以及学生在该课程中获得的**成绩**。

图 1.1 只是这些记录的概念性图片。它没有说明记录如何存储或如何访问。有许多可用的软件产品，称为**数据库系统**，它们提供了一整套用于管理记录的功能。

![fig1-1](/images/chapter1/fig1-1.png)

“管理”记录意味着什么？数据库系统必须具备哪些功能，哪些功能是可选的？以下五个要求似乎是根本性的：

- **数据库必须是持久的。** 否则，一旦计算机关闭，记录就会消失。
- **数据库可以共享。** 许多数据库，例如我们的大学数据库，旨在由多个并发用户共享。
- **数据库必须保持准确。** 如果用户无法信任数据库的内容，它就会变得毫无用处和价值。
- **数据库可能非常庞大。** 图 1.1 的数据库只包含 29 条记录，这小得可笑。数据库包含数百万（甚至数十亿）条记录并不少见。
- **数据库必须可用。** 如果用户无法轻松获取他们想要的数据，他们的生产力就会受到影响，他们就会吵着要不同的产品。

以下小节将探讨这些要求的影响。每个要求都迫使数据库系统包含越来越多的功能，导致其复杂性超出您的预期。

### 1.1.1 记录存储 (Record Storage)

使数据库持久化的一种常见方法是将其记录存储在文件中。最简单直接的方法是数据库系统将记录存储在文本文件中，每种记录类型一个文件；每条记录可以是一行文本，其值用制表符分隔。图 1.2 描绘了 STUDENT 记录文本文件的开头。

这种方法的好处是用户可以用文本编辑器检查和修改文件。不幸的是，这种方法效率太低，无法派上用场，原因有二。

第一个原因是**大型文本文件更新时间过长**。例如，假设有人从 STUDENT 文件中删除了 Joe 的记录。数据库系统别无选择，只能重写从 Amy 记录开始的文件，将每个后续记录向左移动。尽管重写一个小文件所需的时间可以忽略不计，但重写一个 1 GB 的文件很容易花费几分钟，这是不可接受的长时间。数据库系统需要更巧妙地存储记录，以便文件更新只需要小型、局部的重写。

第二个原因是**大型文本文件读取时间过长**。考虑在 STUDENT 文件中搜索 2019 届的学生。唯一的方法是顺序扫描文件。顺序扫描效率可能非常低。您可能知道几种内存中的数据结构，例如树和哈希表，它们可以实现快速搜索。数据库系统需要使用类似的数据结构来实现其文件。例如，数据库系统可能会使用一种结构来组织文件中的记录，以方便某种特定类型的搜索（例如，按学生姓名、毕业年份或专业），或者它可能会创建多个辅助文件，每个文件都方便不同类型的搜索。这些辅助文件称为**索引**，是第 12 章的主题。

### 1.1.2 多用户访问 (Multi-user Access)

当许多用户共享一个数据库时，他们很可能会**并发访问**其某些数据文件。并发性是件好事，因为每个用户都可以快速得到服务，而无需等待其他用户完成。但是过多的并发性是不好的，因为它可能导致数据库变得不准确。例如，考虑一个旅行规划数据库。假设两个用户试图预订一个还有 40 个座位的航班。如果两个用户并发读取相同的航班记录，他们都会看到 40 个可用座位。然后他们都修改记录，使航班现在有 39 个可用座位。糟糕！两个座位已被预订，但数据库中只记录了一个预订。

解决这个问题的方法是**限制并发性**。数据库系统应该允许第一个用户读取航班记录并看到 40 个可用座位，然后阻塞第二个用户，直到第一个用户完成。当第二个用户恢复时，它将看到 39 个可用座位并将其修改为 38，这是正确的。通常，数据库系统必须能够检测到用户何时即将执行与另一个用户的操作冲突的动作，然后（并且仅在此时）阻止该用户执行，直到第一个用户完成。

用户可能还需要**撤消**他们所做的数据库更新。例如，假设用户在旅行规划数据库中搜索马德里的行程，并找到了一个有可用航班和有空房酒店的日期。现在假设用户预订了航班，但在预订过程中，该日期的所有酒店都住满了。在这种情况下，用户可能需要撤消航班预订并尝试不同的日期。

**不可撤消的更新不应该对数据库的其他用户可见**。否则，另一个用户可能会看到更新，认为数据是“真实”的，并根据它做出决定。因此，数据库系统必须为用户提供指定其更改何时永久化的能力；用户被认为**提交**了更改。一旦用户提交，更改就会变得可见且无法撤消。第 5 章将探讨这些问题。

### 1.1.3 处理灾难 (Dealing with Catastrophe)

假设您正在运行一个程序，为所有教授加薪，此时数据库系统意外崩溃。系统重启后，您发现有些教授的工资更新了，但有些没有。您该怎么办？您不能仅仅重新运行程序，因为那样会导致一些教授获得双倍加薪。相反，您需要数据库系统能够从崩溃中**优雅地恢复**，撤消崩溃发生时所有正在运行的程序的更新。这样做的机制很有趣且不简单，将在第 5 章中探讨。

### 1.1.4 内存管理 (Memory Management)

数据库需要存储在**持久内存**中，例如磁盘驱动器或闪存驱动器。闪存驱动器比磁盘驱动器快约 100 倍，但也贵得多。典型的访问时间，磁盘约为 6 毫秒，闪存约为 60 微秒。然而，这两个时间都比主内存（或 RAM）慢几个数量级，RAM 的访问时间约为 60 纳秒。也就是说，RAM 比闪存快约 1000 倍，比磁盘快 100,000 倍。

为了了解这种性能差异的影响以及数据库系统面临的随之而来的问题，请考虑以下类比。假设您想吃一块巧克力曲奇饼。有三种获取方式：从您厨房、从附近杂货店或通过邮购。在这个类比中，您的厨房对应 RAM，附近商店对应闪存驱动器，邮购公司对应磁盘。假设从您的厨房拿到曲奇饼需要 5 秒。从类比商店拿到曲奇饼将需要 5000 秒，超过一小时。这意味着要去商店，排很长的队，买曲奇饼，然后返回。从类比邮购公司拿到曲奇饼将需要 500,000 秒，超过 5 天。这意味着在线订购曲奇饼并使用标准交付方式运输。从这个角度来看，闪存和磁盘内存看起来非常慢。

等等！情况更糟。数据库对并发性和可靠性的支持会使事情变得更慢。如果其他人正在使用您想要的数据，那么您可能被迫等待直到数据被释放。在我们的类比中，这对应于到达杂货店，发现曲奇饼卖完了，迫使您等到它们补货。

换句话说，数据库系统面临以下难题：它必须**管理比主内存系统更多的数据**，**使用更慢的设备**，**多个人争夺数据的访问权**，并且**使其完全可恢复**，同时还要**保持合理的响应时间**。

解决这个难题的很大一部分是使用**缓存**。每当数据库系统需要处理一条记录时，它都会将其加载到 RAM 中并尽可能长时间地保留在那里。因此，主内存将包含当前正在使用的数据库部分。所有读写都发生在 RAM 中。这种策略的优点是使用快速的主内存而不是慢速的持久内存，但缺点是数据库的持久版本可能会过时。数据库系统需要实现技术来使数据库的持久版本与 RAM 版本保持同步，即使在系统崩溃（RAM 内容被销毁时）的情况下也是如此。第 4 章将探讨各种缓存策略。

### 1.1.5 可用性 (Usability)

如果用户无法轻松提取他们想要的数据，数据库就没什么用。例如，假设用户想知道所有 2019 年毕业学生的姓名。在没有数据库系统的情况下，用户将被迫编写一个程序来扫描学生文件。图 1.3 给出了这样一个程序的 Java 代码，假设文件以文本形式存储。请注意，大多数 Java 代码都在处理文件解码、读取每条记录并将其拆分为要检查的值数组。用于确定所需学生姓名（**粗体显示**）的代码隐藏在无趣的文件操作代码中。

```java
public static List<String> getStudents2019() {
    List<String> result = new ArrayList<>();
    FileReader rdr = new FileReader("students.txt");
    BufferedReader br = new BufferedReader(rdr);
    String line = br.readLine();
    while (line != null) {
        String[] vals = line.split("\t");
        String gradyear = vals[2];
        if (gradyear.equals("2019"))
            result.add(vals[1]);
        line = br.readLine();
    }
    return result;
}
```

因此，大多数数据库系统都支持**查询语言**，以便用户可以轻松指定他们想要的数据。关系数据库的标准查询语言是 **SQL**。图 1.3 的代码可以用一个 SQL 语句来表达：

```sql
select SName from STUDENT where GradYear = 2019
```

这个 SQL 语句比 Java 程序短得多、清晰得多，主要是因为它指定了要从文件中提取的值，而无需指定如何检索它们。

### 1.2 Derby 数据库系统 (The Derby Database System)

如果你能交互式地使用数据库系统来学习数据库概念，效果会好得多。尽管有各种各样的数据库系统可用，我建议你使用 Derby 数据库系统，因为它基于 Java，免费，易于安装且易于使用。最新版本的 Derby 可以从 `db.apache.org/derby` 的下载选项卡中下载。下载的发布文件解压后会得到一个包含多个目录的文件夹。例如，`docs` 目录包含参考文档，`demo` 目录包含示例数据库等等。整个系统包含的功能远不止这里能涵盖的；感兴趣的读者可以仔细阅读 `docs` 目录中的各种指南和手册。

Derby 有许多本书不需要的功能。事实上，你只需要将 Derby 的 `lib` 目录中的四个文件添加到你的类路径中：`derby.jar`、`derbynet.jar`、`derbyclient.jar` 和 `derbytools.jar`。更改类路径的方法有很多种，具体取决于你的 Java 平台和操作系统。我将解释如何使用 Eclipse 开发平台进行操作。如果你不熟悉 Eclipse，可以从 `eclipse.org` 下载其代码和文档。如果你使用不同的开发平台，你应该能够调整我的 Eclipse 指南以适应你的环境。

首先，为 Derby 创建一个 Eclipse 项目。然后按如下方式配置其构建路径：从“属性”窗口中，选择“Java 构建路径”。点击“库”选项卡，然后点击“添加外部 JAR”，并使用文件选择器选择你需要的四个 jar 文件。就是这样。

Derby 发布版包含一个名为 `ij` 的应用程序，它使你能够创建和访问 Derby 数据库。因为 Derby 完全用 Java 编写，所以 `ij` 实际上是 Java 类 `org.apache.derby.tools` 包中的一个名称。你通过执行它的类来运行 `ij`。要从 Eclipse 执行该类，请转到“运行”菜单中的“运行配置”。为你的 Derby 项目添加一个新的配置；将其命名为“Derby ij”。在配置主类的字段中，输入“`org.apache.derby.tools.ij`”。当你运行该配置时，`ij` 将显示一个控制台窗口，要求输入。

`ij` 的输入是一系列命令。命令是一个以分号结尾的字符串。命令可以分成几行文本；`ij` 客户端直到遇到以分号结尾的行才会执行命令。任何 SQL 语句都是合法的命令。此外，`ij` 支持连接和断开数据库以及退出会话的命令。

`connect` 命令指定 `ij` 应该连接到的数据库，`disconnect` 命令断开连接。一个给定的会话可以多次连接和断开。`exit` 命令结束会话。图 1.4 展示了一个 `ij` 会话示例。该会话分为两部分。在第一部分中，用户连接到一个新数据库，创建了一个表，向该表中插入了一条记录，然后断开连接。在第二部分中，用户重新连接到该数据库，检索插入的值，然后断开连接。

```shell
ij> connect 'jdbc:derby:ijtest;create=true';
ij> create table T(A int, B varchar(9));
0 rows inserted/updated/deleted
ij> insert into T(A,B) values(3, 'record3');
1 row inserted/updated/deleted
ij> disconnect;
ij> connect 'jdbc:derby:ijtest';
ij> select * from T;
A |B
---------------------
3 |record3
1 row selected
ij> disconnect;
ij> exit;
```

图 1.4 一个 ij 会话示例

`connect` 命令的参数称为其**连接字符串**。连接字符串有三个子字符串，由冒号分隔。前两个子字符串是“`jdbc`”和“`derby`”，表示你想使用 JDBC 协议连接到 Derby 数据库。（JDBC 是第 2 章的主题。）第三个子字符串标识数据库。字符串“`ijtest`”是数据库的名称；它的文件将位于一个名为“`ijtest`”的文件夹中，该文件夹位于启动 `ij` 程序的目录中。例如，如果你从 Eclipse 运行程序，数据库文件夹将位于项目目录中。字符串“`create = true`”告诉 Derby 创建一个新的数据库；如果省略它（如在第二个连接命令中），那么 Derby 将期望找到一个现有数据库。

### 1.3 数据库引擎 (Database Engines)

像 `ij` 这样的数据库应用程序由两个独立的部分组成：**用户界面 (UI)** 和**访问数据库的代码**。后一部分代码称为**数据库引擎**。将 UI 与数据库引擎分离是良好的系统设计，因为它简化了应用程序的开发。这种分离的一个著名例子出现在 Microsoft Access 数据库系统中。它有一个图形 UI，允许用户通过点击鼠标和填写值与数据库交互，还有一个处理数据存储的引擎。当 UI 确定它需要数据库中的信息时，它会构建一个请求并将其发送给引擎。然后引擎执行请求并将值发送回 UI。

这种分离还增加了系统的灵活性：应用程序设计人员可以使用相同的用户界面与不同的数据库引擎，或者为相同的数据库引擎构建不同的用户界面。Microsoft Access 为每种情况都提供了一个示例。使用 Access UI 构建的表单可以连接到 Access 引擎或任何其他数据库引擎。Excel 电子表格中的单元格可以包含查询 Access 引擎的公式。

UI 通过连接到所需的引擎，然后调用引擎 API 中的方法来访问数据库。例如，请注意 Derby `ij` 程序实际上只是一个 UI。它的 `connect` 命令建立与指定数据库引擎的连接，每个 SQL 命令将 SQL 语句发送到引擎，检索结果并显示它们。

数据库引擎通常支持多种标准 API。当 Java 程序连接到引擎时，首选的 API 称为 **JDBC**。第 2 章详细讨论 JDBC，并展示如何使用 JDBC 编写类似 `ij` 的应用程序。

从 UI 到数据库引擎的连接可以是**嵌入式**或**基于服务器**的。在嵌入式连接中，数据库引擎的代码与 UI 的代码在同一个进程中运行，这使得 UI 独占访问引擎。只有当数据库“属于”该应用程序并且存储在与应用程序相同的机器上时，应用程序才应该使用嵌入式连接。其他应用程序需要使用基于服务器的连接。

在基于服务器的连接中，数据库引擎的代码在专用的服务器程序内部执行。这个服务器程序始终在运行，等待客户端连接，并且不需要与客户端在同一台机器上。客户端与服务器建立连接后，客户端向服务器发送 JDBC 请求并接收响应。

一个服务器可以同时连接到多个客户端。当服务器处理一个客户端的请求时，其他客户端可以发送自己的请求。服务器包含一个**调度器**，它将等待服务的请求排队，并确定它们何时执行。每个客户端都不知道其他客户端，并且（除了由于调度引起的延迟之外）愉快地认为服务器正在独占地处理它。

图 1.4 的 `ij` 会话使用了**嵌入式连接**。它在运行会话的机器上创建了数据库“`ijtest`”，并且没有涉及服务器。要执行类似的**基于服务器的 `ij` 会话**，必须更改两件事：Derby 引擎必须作为服务器运行，并且 `connect` 命令必须修改以标识服务器。

Derby 服务器的代码在 Java 类 `NetworkServerControl` 中，位于 `org.apache.derby.drda` 包中。要从 Eclipse 运行服务器，请转到“运行”菜单中的“运行配置”。为你的 Derby 项目添加一个新的配置，并将其命名为“Derby Server”。在主类的字段中，输入“`org.apache.derby.drda.NetworkServerControl`”。在“参数”选项卡中，输入程序参数“`start -h localhost`”。每次运行配置时，都会出现一个控制台窗口，指示 Derby 服务器正在运行。

程序参数“`start -h localhost`”的目的是什么？第一个词是命令“`start`”，它告诉该类启动服务器。你可以通过使用参数“`shutdown`”执行相同的类来停止服务器（或者你可以直接从控制台窗口终止进程）。字符串“`-h localhost`”告诉服务器只接受来自同一机器上客户端的请求。如果你将“`localhost`”替换为域名或 IP 地址，那么服务器将只接受来自该机器的请求。使用 IP 地址“`0.0.0.0`”告诉服务器接受来自任何地方的请求。

基于服务器的连接的连接字符串必须指定服务器机器的网络或 IP 地址。特别是，请考虑以下 `ij` 连接命令：

- `ij> connect 'jdbc:derby:ijtest'`
- `ij> connect 'jdbc:derby://localhost/ijtest'`
- `ij> connect 'jdbc:derby://cs.bc.edu/ijtest'`

第一个命令建立与“`ijtest`”数据库的**嵌入式连接**。第二个命令使用在“`localhost`”机器（即本地机器）上运行的服务器建立与“`ijtest`”的**基于服务器的连接**。第三个命令使用在“`cs.bc.edu`”机器上运行的服务器建立与“`ijtest`”的**基于服务器的连接**。

请注意 `connect` 字符串如何完全封装了使用嵌入式或服务器端连接的决定。例如，再次考虑图 1.4。你可以通过简单地更改 `connect` 命令来修改会话，使其使用服务器端连接而不是嵌入式连接。会话中的其他命令不受影响。
