---
typora-root-url: ./..\..\public
---

# 第 6 章 记录管理 (Record Management)

事务管理器能够在磁盘块上的指定位置读写值。然而，它并不知道块中有哪些值，也不知道这些值可能位于何处。这个责任属于**记录管理器 (record manager)**。它将文件组织成记录集合，并提供了遍历记录和在其中放置值的方法。本章研究记录管理器提供的功能以及实现该功能所使用的技术。

## 6.1 设计记录管理器 (Designing a Record Manager)

记录管理器必须解决几个问题，例如：

- 每条记录是否应完全放置在一个块内？
- 块中的所有记录是否都来自同一张表？
- 每个字段是否可以使用预定数量的字节表示？
- 每个字段值应该在记录中的哪个位置？

本节讨论这些问题及其权衡。

### 6.1.1 跨块记录与非跨块记录 (Spanned Versus Unspanned Records)

假设记录管理器需要将四个 300 字节的记录插入到一个文件中，其中块大小为 1000 字节。三个记录可以很好地放入块的前 900 字节。但是记录管理器应该如何处理第四个记录呢？图 6.1 展示了两种选择。

![fig6-1](/images/chapter6/fig6-1.png)

 **图 6.1 跨块记录与非跨块记录. (a) R4 记录跨越块 0 和块 1, (b)R4 记录完全存储在块 1 中**

在图 6.1a 中，记录管理器创建一个**跨块记录 (spanned record)**，即其值跨越两个或更多块的记录。它将记录的前 100 字节存储在现有块中，将记录的后 200 字节存储在新块中。在图 6.1b 中，记录管理器将整个第四个记录存储在一个新块中。

记录管理器必须决定是否创建跨块记录。**非跨块记录 (unspanned records)** 的缺点是它们浪费磁盘空间。在图 6.1b 中，每个块浪费了 100 字节（或 10%）。更糟糕的情况是，如果每个记录包含 501 字节——那么一个块只能包含 1 条记录，并且近 50% 的空间将被浪费。另一个缺点是，非跨块记录的大小受限于块大小。如果记录可以大于一个块，那么跨块是必要的。

跨块记录的主要缺点是它们增加了**记录访问的复杂性 (complexity of record access)**。因为跨块记录分布在多个块中，所以读取它需要多次块访问。此外，跨块记录可能需要通过将其读入内存的单独区域来从这些块中重建。

### 6.1.2 同构文件与非同构文件 (Homogeneous Versus Nonhomogeneous Files)

如果文件中的所有记录都来自同一张表，则该文件是**同构的 (homogeneous)**。记录管理器必须决定是否允许**非同构文件 (nonhomogeneous files)**。权衡再次是**效率 (efficiency)** 与**灵活性 (flexibility)**。

例如，考虑 图 1.1 中的 `STUDENT` 和 `DEPT` 表。同构实现会将所有 `STUDENT` 记录放在一个文件中，所有 `DEPT` 记录放在另一个文件中。这种放置使得**单表 SQL 查询 (single-table SQL queries)** 易于回答——记录管理器只需扫描一个文件的块。然而，**多表查询 (multi-table queries)** 的效率会降低。考虑一个连接这两个表的查询，例如“查找学生姓名及其主修系”。记录管理器必须在 `STUDENT` 记录的块和 `DEPT` 记录的块之间来回搜索（如第 8 章将讨论），寻找匹配的记录。即使查询可以在没有过多搜索的情况下执行（例如，通过第 12 章的**索引连接 (index join)**），磁盘驱动器仍然必须在读取 `STUDENT` 和 `DEPT` 块之间交替时重复寻道。

**非同构组织 (nonhomogeneous organization)** 会将 `STUDENT` 和 `DEPT` 记录存储在同一个文件中，每个学生的记录存储在其主修系记录的附近。图 6.2 描绘了这种组织的前两个块，假设每个块有三条记录。文件由一条 `DEPT` 记录组成，后面跟着以该系为主修的 `STUDENT` 记录。这种组织需要更少的块访问来计算连接，因为连接的记录**聚簇 (clustered)** 在同一个（或附近的）块中。

![fig6-2](/images/chapter6/fig6-2.png)

 **图 6.2 聚簇、非同构记录**

**聚簇 (Clustering)** 提高了连接聚簇表的查询效率，因为匹配的记录存储在一起。然而，聚簇会导致单表查询效率降低，因为每张表的记录分布在更多的块中。同样，与其他表的连接效率也会降低。因此，聚簇仅在最常用的查询执行由聚簇编码的连接时才有效。

### 6.1.3 定长字段与变长字段 (Fixed-Length Versus Variable-Length Fields)

表中的每个字段都有一个定义好的类型。基于该类型，记录管理器决定是使用**定长 (fixed-length)** 还是**变长 (variable-length)** 表示来实现字段。定长表示使用完全相同的字节数来存储字段的每个值，而变长表示则根据存储的数据值进行扩展和收缩。

大多数类型自然是定长的。例如，整数和浮点数都可以存储为 4 字节的二进制值。事实上，所有数字和日期/时间类型都具有自然的定长表示。Java 类型 `String` 是需要变长表示的典型示例，因为字符串可以任意长。

变长表示会带来显著的复杂性。例如，考虑一个位于块中间且充满记录的记录，并假设您修改了其一个字段值。如果字段是定长的，那么记录的大小将保持不变，并且可以在原地修改字段。但是，如果字段是变长的，那么记录可能会变大。为了给更大的记录腾出空间，记录管理器可能必须**重新排列 (rearrange)** 块中记录的位置。事实上，如果修改后的记录变得太大，那么一个或多个记录可能需要移出该块并放置在不同的块中。因此，记录管理器会尽力在可能的情况下使用定长表示。例如，记录管理器可以从字符串字段的三种不同表示中选择：

- **变长表示 (A variable-length representation)**：记录管理器在记录中为字符串分配所需的精确空间量。
- **定长表示 (A fixed-length representation)**：记录管理器将字符串存储在记录外部的位置，并在记录中保留对该位置的定长引用。
- **定长表示 (A fixed-length representation)**：记录管理器在记录中为每个字符串分配相同数量的空间，无论其长度如何。

![fig6-3](/images/chapter6/fig6-3.png)

**图 6.3 `COURSE` 记录中 `Title` 字段的不同表示方法, (a) 为每个字符串分配刚好所需的空间,(b)将字符串存储在单独的位置,(c) 为每个字符串分配相同数量的空间**

这些表示如 图 6.3 所示。图 (a) 显示了三个 `COURSE` 记录，其中 `Title` 字段使用变长表示实现。这些记录空间效率高，但存在刚刚讨论的问题。

图 (b) 显示了相同的三个记录，但 `Title` 字符串放置在单独的“字符串区域”中。该区域可以是单独的文件，或者（如果字符串非常大）一个目录，其中每个字符串都存储在自己的文件中。在任何一种情况下，字段都包含对字符串在该区域中位置的引用。这种表示使记录既**定长 (fixed-length)** 又**小巧 (small)**。小记录是好的，因为它们可以存储在更少的块中，因此需要更少的块访问。这种表示的缺点是，从记录中检索字符串值需要额外的块访问。

图 (c) 显示了其中两个记录，使用定长 `Title` 字段实现。这种实现的优点是记录是定长的，并且字符串存储在记录中。然而，缺点是一些记录会比它们需要的更大。如果字符串大小差异很大，那么这种浪费的空间将是显著的，导致文件更大，从而需要更多的块访问。

这些表示方式没有一个明显优于其他。为了帮助记录管理器选择合适的表示方式，标准 SQL 提供了三种不同的字符串数据类型：`char`、`varchar` 和 `clob`。`char(n)` 类型指定恰好 `n` 个字符的字符串。`varchar(n)` 和 `clob(n)` 类型指定最多 `n` 个字符的字符串。它们的区别在于 `n` 的预期大小。在 `varchar(n)` 中，`n` 相对较小，例如不超过 4K。另一方面，`clob(n)` 中 `n` 的值可以达到千兆字符范围。（`CLOB` 是“字符大对象”的缩写。）举一个 `clob` 字段的例子，假设大学数据库在其 `SECTION` 表中添加了一个 `Syllabus` 字段，其值将包含每个课程大纲的文本。假设大纲最多可包含 8000 个字符，您可以合理地将该字段定义为 `clob(8000)`。

`char` 类型的字段最自然地对应于图 6.3c。由于所有字符串都将具有相同的长度，因此记录内部没有浪费空间，并且定长表示将是最有效的。

`varchar(n)` 类型的字段最自然地对应于图 6.3a。由于 `n` 将相对较小，将字符串放置在记录内部不会使记录太大。此外，字符串大小的变化意味着定长表示会浪费空间。因此，变长表示是最好的选择。如果 `n` 碰巧很小（例如，小于 20），那么记录管理器可能会选择使用第三种表示来实现 `varchar` 字段。原因是与定长表示的优点相比，浪费的空间将微不足道。

`clob` 类型的字段对应于图 6.3b，因为该表示最能处理大字符串。通过将大字符串存储在记录外部，记录本身变得更小、更易于管理。

### 6.1.4 字段在记录中的放置 (Placing Fields in Records)

记录管理器确定其记录的结构。对于**定长记录 (fixed-length records)**，它确定每个字段在记录中的位置。最直接的策略是将字段彼此相邻存储。记录的大小然后变为字段大小的总和，每个字段的偏移量是前一个字段的结尾。

这种将字段紧密打包到记录中的策略适用于基于 Java 的系统（如 SimpleDB 和 Derby），但在其他地方可能会导致问题。问题在于确保值在内存中正确**对齐 (aligned)**。在大多数计算机中，访问整数的机器代码要求整数存储在 4 的倍数的内存位置中；据说整数**对齐在 4 字节边界上 (aligned on a 4-byte boundary)**。因此，记录管理器必须确保每个页面中的每个整数都对齐在 4 字节边界上。由于 OS 页面总是对齐在 2 的 N 次幂字节边界上（N 为某个合理大的整数），因此每个页面的第一个字节将正确对齐。因此，记录管理器必须简单地确保每个页面中每个整数的偏移量是 4 的倍数。如果前一个字段的结尾位置不是 4 的倍数，那么记录管理器必须用足够的字节**填充 (pad)** 它，使其成为 4 的倍数。

例如，考虑 `STUDENT` 表，它由三个整数字段和一个 `varchar(10)` 字符串字段组成。整数字段是 4 的倍数，因此它们不需要填充。然而，字符串字段需要 14 个字节（假设第 3.5.2 节的 SimpleDB 表示）；因此，它需要填充额外的 2 个字节，以便其后的字段将对齐在 4 的倍数上。

通常，不同的类型可能需要不同数量的填充。例如，双精度浮点数通常对齐在 8 字节边界上，而小整数通常对齐在 2 字节边界上。记录管理器负责确保这些对齐。一个简单的策略是按声明顺序放置字段，填充每个字段以确保下一个字段的正确对齐。一个更巧妙的策略是**重新排序 (reorder)** 字段，以便所需填充量最少。例如，考虑以下 SQL 表声明：

```sql
create table T (A smallint, B double precision, C smallint, D int, E int)
```

假设字段按给定顺序存储。那么字段 A 需要填充额外的 6 个字节，字段 C 需要填充额外的 2 个字节，导致记录长度为 28 字节；参见 图 6.4a。另一方面，如果字段按顺序 `[B, D, A, C, E]` 存储，则不需要填充，记录长度仅为 20 字节，如 图 6.4b 所示。

![fig6-4](/images/chapter6/fig6-4.png)

 **图 6.4 记录中字段的放置以实现对齐 ,(a)需要填充的放置方式图 ,(b) 不需要填充的放置方式**

除了填充字段，记录管理器还必须**填充 (pad)** 每条记录。其思想是每条记录需要以 k 字节边界结束，其中 k 是支持的最大对齐方式，以便页面中的每条记录都与第一条记录具有相同的对齐方式。再次考虑 图 6.4a 的字段放置，其记录长度为 28 字节。假设第一条记录从块的字节 0 开始。那么第二条记录将从块的字节 28 开始，这意味着第二条记录的字段 B 将从块的字节 36 开始，这是错误的对齐方式。**每条记录都必须从 8 字节边界开始**至关重要。在图 6.4 的示例中，部分 (a) 和部分 (b) 的记录都需要填充额外的 4 个字节。

Java 程序不需要考虑填充，因为它不能直接访问字节数组中的数值。例如，从页面读取整数的 Java 方法是 `ByteBuffer.getInt`。此方法不调用机器代码指令来获取整数，而是从数组的 4 个指定字节中构造整数本身。此活动不如单个机器代码指令高效，但它避免了对齐问题。
